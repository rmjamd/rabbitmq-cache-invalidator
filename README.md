
# Cache invalidation using Rabbitmq




## Introductions

 Caching is a fundamental technique for improving system performance by storing frequently accessed data closer to the application. However, in distributed systems where multiple instances of an application are running, maintaining cache consistency becomes challenging. Cache invalidation is the process of removing or updating cached data to ensure data integrity and synchronization across distributed systems. This documentation explores cache invalidation strategies and demonstrates the implementation of a cache invalidation system using RabbitMQ, a popular message broker.

 ## Designing
1. Create Message Bus: The first step is to create a message bus, which acts as a central
component for cache invalidation. The message bus is responsible for managing the
connection with the message broker (such as RabbitMQ) and generating a unique ID for
each class or component that needs cache invalidation.

2. Create a Message Topic: Once the message bus is set up, you can create a cached topic.
A cache topic represents a specific topic or channel for cache invalidation messages.
When creating a Message topic, you need to provide the topic name and the data type
associated with cache invalidation.

3. Publish Cache Invalidation Data: With the Message topic created, you can publish cache
invalidation data to the associated queue. This can be done by invoking the publish
method of the cache topic and providing the cache key or relevant data that needs to be
invalidated.

4. Consume Cache Invalidation Data: The cache topic also allows consuming cache
invalidation data from the associated queue. This is done by registering a callback
function. The callback function is executed asynchronously when a cache invalidation
message is received, allowing you to handle the cache invalidation logic.

5. Cache Invalidation Function: Within the callback function, you will invoke the cache
invalidation function or method to invalidate the cache based on the received data. This
is the place where you can implement your specific cache invalidation logic, such as
removing or updating cache entries.

6. Unique ID Checking: To prevent duplicate cache invalidation actions, it is essential to
incorporate a unique ID check. Each class or component that needs cache invalidation
will have a unique ID generated by the message bus. When receiving cache invalidation
data, you can compare the ID associated with the received data with the ID of the
current class or component. If they match, you can ignore the data as it has already
been invalidated.

## Documentation

[Documentation](https://github.com/rmjamd/DistributedCacheInvalidator/blob/master/cache_invalidation_docs.pdf)


## Prerequisites
Before proceeding, make sure you have Docker installed and running. If not, follow the installation steps provided in the  section.

[Docker](https://docs.docker.com/engine/install/)
## Installation
Clone the Repo
```bash
  git clone git@github.com:rmjamd/DistributedCacheInvalidator.git
  cd CacheInvalidator
```
Create a Docker Network
```bash
  docker network create springboot-mysql-net
```
Run Mysqll and Rabbitmq in Same Docker Network
```bash

docker run -d --name rabbitmq-container -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=guest -e RABBITMQ_DEFAULT_PASS=guest --network 


docker run --name mysqldb --network springboot-mysql-net -e MYSQL_ROOT_PASSWORD=12345678 -e MYSQL_DATABASE=cacheinvalidator -d mysql
```
Build the Image 
```bash
docker build -t cacheinvalidator .
```
Run the same image in 3 port
```bash
docker run --network springboot-mysql-net --name server1 -p 8080:8080 cacheinvalidator

docker run --network springboot-mysql-net --name server2 -p 8081:8080 cacheinvalidator

docker run --network springboot-mysql-net --name server2 -p 8082:8080 cacheinvalidator

```
## API Reference

[Postman Collection](https://github.com/rmjamd/DistributedCacheInvalidator/blob/master/postman_collection.json)
## Usage

Caching is a fundamental technique for improving system performance by storing frequently accessed data closer to the application. However, in distributed systems where multiple instances of an application are running, maintaining cache consistency becomes challenging. Cache invalidation is the process of removing or updating cached data to ensure data integrity and synchronization across distributed systems.Distributed cache invalidation using RabbitMQ as the message broker enables seamless cache synchronization across distributed systems. With the publisher sending cache invalidation messages and consumers updating or invalidating their local caches accordingly, the distributed cache remains consistent and up-to-date, improving overall system performance and reliability. The usage of RabbitMQ simplifies communication and decouples cache invalidation from the application logic, making it a powerful tool for building scalable and efficient distributed systems.
